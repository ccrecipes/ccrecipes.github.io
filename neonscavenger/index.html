<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Scavenger: WebGL</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PixiJS Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            background-color: #000;
            color: white;
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
            user-select: none;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #050505;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- CSS UI OVERLAYS --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 60;
        }

        .crt-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 50;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            box-shadow: inset 0 0 100px rgba(0,0,0,0.9);
        }

        .pointer-events-auto { pointer-events: auto; }
        .neon-text { text-shadow: 0 0 5px #0ff; }
        
        .btn-neon {
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #0ff;
            color: #0ff;
            box-shadow: 0 0 10px #0ff;
            transition: all 0.2s;
        }
        .btn-neon:hover { background: #0ff; color: #000; transform: scale(1.05); }
        .btn-neon:disabled { border-color: #333; color: #333; box-shadow: none; transform: none; }

        .health-bar-bg { background: #333; height: 8px; width: 100%; border: 1px solid #fff; }
        .health-bar-fill { background: #f00; height: 100%; width: 100%; transition: width 0.1s; }
        
        .progress-bar-bg { background: rgba(0,0,0,0.5); height: 6px; width: 100%; border: 1px solid #333; margin-top: 5px; }
        .progress-bar-fill { background: #0ff; height: 100%; width: 0%; box-shadow: 0 0 5px #0ff; transition: width 0.1s linear; }

        .fade-in { animation: fadeIn 2s ease-out forwards; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        
        .upgrade-card {
            background: rgba(0, 20, 40, 0.95);
            border: 1px solid #0ff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.1);
        }

        /* --- OSU STYLE MENU --- */
        .osu-logo {
            animation: pulse-logo 2s infinite ease-in-out;
            cursor: pointer;
            transition: transform 0.1s;
        }
        .osu-logo:hover {
            transform: scale(1.05);
        }
        .osu-logo:active {
            transform: scale(0.95);
        }
        @keyframes pulse-logo {
            0% { box-shadow: 0 0 20px #0ff; }
            50% { box-shadow: 0 0 50px #0ff, 0 0 100px cyan; }
            100% { box-shadow: 0 0 20px #0ff; }
        }

        .track-item {
            /* Thicker tracks */
            height: 96px; 
            border-right: 6px solid #444;
            transform: skewX(-15deg);
            transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
            cursor: pointer;
            padding-right: 50px;
            padding-left: 20px;
            
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: flex-end;
            
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            
            /* Initial state handled by JS inline styles for bg image */
            box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
            overflow: hidden; 
        }

        .track-item:hover {
            transform: skewX(-15deg) translateX(-20px);
            border-right-color: #0ff;
        }

        .track-item.selected {
            border-right-color: #d946ef;
            transform: skewX(-15deg) translateX(-60px);
            width: Calc(100% + 40px);
            z-index: 10;
            box-shadow: 0 0 20px rgba(217, 70, 239, 0.3);
        }
        
        .track-content {
            transform: skewX(15deg); 
            text-align: right;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        /* Marquee Animation */
        @keyframes marquee-scroll {
            0%, 20% { transform: translateX(0); }
            50%, 70% { transform: translateX(var(--scroll-dist)); }
            100% { transform: translateX(0); }
        }

        .marquee-container {
            overflow: hidden;
            white-space: nowrap;
            max-width: 25vw; /* Hard limit for width */
            text-align: right;
            display: block; 
            position: relative;
        }

        .marquee-content {
            display: inline-block;
        }

        .animate-marquee {
            animation: marquee-scroll 8s linear infinite;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div class="crt-overlay"></div>

        <div id="ui-layer" class="flex flex-col justify-between p-6">
            <div id="hud" class="hidden flex justify-between items-start w-full">
                <div class="w-1/3">
                    <div class="text-xs text-gray-400">INTEGRITY</div>
                    <div class="health-bar-bg mb-2"><div id="healthFill" class="health-bar-fill"></div></div>
                    <div class="text-xl neon-text origin-left transition-transform duration-75" id="scoreContainer">SCORE: <span id="scoreVal">0</span></div>
                </div>
                <div id="songProgressContainer" class="w-1/3 px-4 opacity-0 transition-opacity">
                    <div class="text-xs text-center text-cyan-400">TRACK SYNCHRONIZATION</div>
                    <div class="progress-bar-bg"><div id="songProgressFill" class="progress-bar-fill"></div></div>
                </div>
                <div class="text-right w-1/3">
                    <div class="text-xs text-gray-400">SHARDS</div>
                    <div class="text-2xl text-yellow-400 font-bold">ðŸ’Ž <span id="currencyVal">0</span></div>
                </div>
            </div>

            <!-- OSU STYLE MAIN MENU -->
            <div id="mainMenu" class="absolute inset-0 pointer-events-auto overflow-hidden">
                <!-- Center Logo / Play Button -->
                <div class="absolute left-[10%] top-1/2 -translate-y-1/2 flex flex-col items-center z-20">
                    <div id="startBtn" class="osu-logo w-72 h-72 rounded-full border-[8px] border-white bg-black/90 flex items-center justify-center relative group shadow-2xl">
                        <!-- Inner detail ring -->
                        <div class="absolute inset-3 rounded-full border-2 border-cyan-500/50"></div>
                        <div class="text-center z-10">
                            <h1 class="text-4xl font-black text-white italic tracking-tighter leading-tight drop-shadow-lg">NEON<br><span class="text-5xl text-cyan-300">SCAVENGER</span></h1>
                            <div class="mt-3 text-sm text-cyan-400 font-bold tracking-[0.3em] opacity-80 group-hover:opacity-100 transition-opacity">CLICK TO START</div>
                        </div>
                    </div>
                    
                    <div class="mt-16 flex gap-6">
                        <button id="shopBtn" class="btn-neon px-10 py-4 text-xl font-bold rounded skew-x-[-15deg] hover:bg-yellow-400/20 text-yellow-400 border-yellow-400 shadow-[0_0_15px_rgba(250,204,21,0.3)]">
                            <span class="inline-block skew-x-[15deg]">TECH LAB</span>
                        </button>
                    </div>
                </div>

                <!-- Right Side Track Selection -->
                <div class="absolute right-0 top-0 h-full w-[45%] bg-gradient-to-l from-black via-black/90 to-transparent flex flex-col pt-24 pb-12 overflow-hidden z-10 pointer-events-none">
                    <div class="text-right pr-12 mb-6 pointer-events-auto">
                        <h2 class="text-5xl font-black text-white italic drop-shadow-md">SELECT TRACK</h2>
                        <p class="text-sm text-cyan-400 font-mono tracking-widest mt-1">SYNC YOUR GAMEPLAY</p>
                    </div>

                    <!-- Track List Container -->
                    <div id="trackList" class="flex flex-col gap-3 w-full pl-32 pointer-events-auto overflow-y-auto pr-4" style="scrollbar-width: none;">
                        <!-- Tracks injected by JS -->
                    </div>

                    <!-- Custom Upload at Bottom -->
                    <div class="mt-auto mr-[-40px] pr-16 pl-32 transform skew-x-[-15deg] bg-cyan-900/40 border-l-8 border-cyan-500 py-6 hover:translate-x-[-15px] transition-transform pointer-events-auto cursor-pointer relative group">
                        <div class="absolute inset-0 bg-gradient-to-r from-transparent to-cyan-500/10 group-hover:to-cyan-500/20 transition-all"></div>
                        <div class="transform skew-x-[15deg] text-right relative z-10">
                            <label class="block text-lg font-bold text-cyan-300 mb-1 cursor-pointer hover:text-white transition-colors">
                                ðŸ“‚ IMPORT CUSTOM AUDIO
                                <input type="file" id="musicUpload" accept="audio/*" class="hidden"/>
                            </label>
                            <div id="customFileName" class="text-xs text-gray-400 font-mono truncate">No file selected</div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="shopMenu" class="hidden absolute inset-0 flex flex-col items-center justify-center bg-black/95 pointer-events-auto z-50">
                <h2 class="text-4xl font-bold text-yellow-400 mb-8">TECH LAB</h2>
                <div class="text-xl mb-4">CREDITS: <span id="shopCurrency" class="text-yellow-400">0</span></div>
                <div class="grid grid-cols-2 gap-4 w-full max-w-4xl px-4">
                    <div class="upgrade-card p-4 rounded"><h3 class="text-cyan-300">PLASMA OUTPUT</h3><div class="text-xs text-gray-400">Increase Damage</div><button id="buyDmg" class="btn-neon w-full mt-2 text-xs py-1">UPGRADE</button><div class="text-right text-xs mt-1" id="dmgCost">100</div></div>
                    <div class="upgrade-card p-4 rounded"><h3 class="text-green-300">CYCLER SPEED</h3><div class="text-xs text-gray-400">Increase Fire Rate</div><button id="buyRate" class="btn-neon w-full mt-2 text-xs py-1 border-green-400 text-green-400">UPGRADE</button><div class="text-right text-xs mt-1" id="rateCost">100</div></div>
                    <div class="upgrade-card p-4 rounded"><h3 class="text-purple-300">THRUSTERS</h3><div class="text-xs text-gray-400">Increase Speed</div><button id="buySpd" class="btn-neon w-full mt-2 text-xs py-1 border-purple-400 text-purple-400">UPGRADE</button><div class="text-right text-xs mt-1" id="spdCost">100</div></div>
                    <div class="upgrade-card p-4 rounded"><h3 class="text-pink-300">VACUUM FIELD</h3><div class="text-xs text-gray-400">Magnet Range</div><button id="buyMag" class="btn-neon w-full mt-2 text-xs py-1 border-pink-400 text-pink-400">UPGRADE</button><div class="text-right text-xs mt-1" id="magCost">100</div></div>
                </div>
                <button id="closeShop" class="mt-8 text-gray-400 hover:text-white underline">RETURN</button>
            </div>

            <div id="gameOver" class="hidden absolute inset-0 flex flex-col items-center justify-center bg-red-900/60 backdrop-blur-sm pointer-events-auto z-50">
                <h2 class="text-6xl font-black text-white mb-2" style="text-shadow: 0 0 30px red;">SYSTEM FAILURE</h2>
                <div class="text-2xl mb-6 text-white">DATA SECURED: <span id="finalShards" class="text-yellow-400 font-bold">0</span></div>
                <button id="retryBtn" class="btn-neon px-8 py-3 text-lg font-bold rounded mb-4">REBOOT</button>
                <button id="goShopBtn" class="text-sm text-gray-300 hover:text-white underline">ACCESS TECH LAB</button>
            </div>

            <div id="gameSuccess" class="hidden absolute inset-0 flex flex-col items-center justify-center bg-green-900/60 backdrop-blur-sm pointer-events-auto z-50">
                <h2 class="text-6xl font-black text-white mb-2" style="text-shadow: 0 0 30px #4ade80;">MISSION COMPLETE</h2>
                <div class="text-2xl mb-6 text-white">DATA SECURED: <span id="successShards" class="text-yellow-400 font-bold">0</span></div>
                <button id="successRetryBtn" class="btn-neon px-8 py-3 text-lg font-bold rounded border-green-400 text-green-400 hover:bg-green-400 hover:text-black">REBOOT</button>
                <button id="successGoShopBtn" class="mt-4 text-sm text-gray-300 hover:text-white underline">ACCESS TECH LAB</button>
            </div>
        </div>
    </div>

    <script>
        const container = document.getElementById('game-container');
        const app = new PIXI.Application({
            resizeTo: container,
            backgroundAlpha: 0, 
            antialias: true,
            resolution: window.devicePixelRatio || 1,
            autoDensity: true
        });
        container.appendChild(app.view);

        const gameContainer = new PIXI.Container();
        app.stage.addChild(gameContainer);

        // Graphics for Glitch Effect (Top Layer)
        const glitchGraphics = new PIXI.Graphics();
        app.stage.addChild(glitchGraphics);

        // --- CRT BARREL DISTORTION SHADER ---
        const crtFrag = `
            precision mediump float;
            varying vec2 vTextureCoord;
            uniform sampler2D uSampler;
            
            void main(void) {
                vec2 uv = vTextureCoord;
                // Center UV
                uv = uv * 2.0 - 1.0;
                
                // Barrel Distortion
                vec2 offset = uv.yx / 5.0; // Curvature amount
                uv = uv + uv * offset * offset;
                
                // Un-center
                uv = uv * 0.5 + 0.5;
                
                if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                } else {
                    gl_FragColor = texture2D(uSampler, uv);
                }
            }
        `;
        const crtFilter = new PIXI.Filter(null, crtFrag);
        app.stage.filters = [crtFilter];

        // --- LAYER SETUP ---
        const bgGraphics = new PIXI.Graphics();
        gameContainer.addChild(bgGraphics);

        const gridGraphics = new PIXI.Graphics();
        gameContainer.addChild(gridGraphics);

        const glowContainer = new PIXI.Container();
        const coreContainer = new PIXI.Container();
        gameContainer.addChild(glowContainer);
        gameContainer.addChild(coreContainer);

        const neonFilter = new PIXI.BlurFilter(8); 
        glowContainer.filters = [neonFilter];
        glowContainer.alpha = 0.8; 

        let width = app.screen.width;
        let height = app.screen.height;
        let arenaApothem = Math.min(width, height) * 0.65;

        window.addEventListener('resize', () => {
            width = app.screen.width;
            height = app.screen.height;
            arenaApothem = Math.min(width, height) * 0.65;
            gameContainer.x = width / 2;
            gameContainer.y = height / 2;
            drawBorder();
        });

        gameContainer.x = width / 2;
        gameContainer.y = height / 2;

        const defaultSave = { currency: 0, upgrades: { damage: 1, fireRate: 1, speed: 1, magnet: 1 } };
        let saveData = JSON.parse(localStorage.getItem('neonScavengerSave')) || defaultSave;
        
        const saveGame = () => {
            localStorage.setItem('neonScavengerSave', JSON.stringify(saveData));
            updateShop(); 
        };
        
        let gameState = {
            running: false,
            score: 0,
            currency: 0,
            runCurrency: 0,
            spawnTimer: 0,
            isDying: false,
            deathTimer: 0,
            timeScale: 1.0,
            screenShake: 0,
            mouse: { x: 0, y: 0 }
        };

        const entities = {
            player: null,
            bullets: [],
            enemies: [],
            particles: [],
            shockwaves: [],
            loot: [],
            borderCore: new PIXI.Graphics(),
            borderGlow: new PIXI.Graphics()
        };
        
        coreContainer.addChild(entities.borderCore);
        glowContainer.addChild(entities.borderGlow);

        const audio = {
            ctx: null,
            analyser: null,
            dataArray: null,
            element: new Audio(),
            setup: false,
            beatValue: 0
        };

        // --- TRACK SYSTEM (JSON CONFIG) ---
        const tracks = [
            { 
                id: "track1",
                title: "I Really Want to Stay at Your House", 
                artist: "Rosa Walton", 
                src: "./tracks/Rosa_Walton_I_Really_Want_to_Stay_at_Your_House.mp3", 
                cover: "./covers/Rosa_Walton_I_Really_Want_to_Stay_at_Your_House.jpg", 
                duration: "4:11" 
            },
            { 
                id: "track2",
                title: "Cyber City Lights", 
                artist: "Teamfight Tactics", 
                src: "./tracks/Cyber_City_Lights.mp3", 
                cover: "./covers/cybercity_lights.jpg", 
                duration: "4:21" 
            },
            { 
                id: "track3",
                title: "Saving Light", 
                artist: "Wuthering Waves, Thena A, N2V, xTOx, VISION SOUND", 
                src: "./tracks/Saving_Light.mp3", 
                cover: "./covers/Saving_Light.jpg", 
                duration: "2:58" 
            }
        ];
        let selectedTrackIndex = 0;

        function renderTrackList() {
            const list = document.getElementById('trackList');
            list.innerHTML = '';
            tracks.forEach((track, idx) => {
                const div = document.createElement('div');
                div.className = `track-item ${idx === selectedTrackIndex ? 'selected' : ''}`;
                
                // Dynamic Background Logic
                if (idx === selectedTrackIndex) {
                    div.style.backgroundImage = `linear-gradient(90deg, rgba(0,0,0,0.6) 0%, rgba(217, 70, 239, 0.2) 100%), url('${track.cover}')`;
                } else {
                    div.style.backgroundImage = `linear-gradient(to right, #000 0%, #000 30%, transparent 100%), url('${track.cover}')`;
                }

                div.innerHTML = `
                    <div class="track-content relative z-10">
                        <div class="marquee-container" id="track-title-${idx}">
                            <div class="marquee-content text-2xl font-black text-white leading-none uppercase drop-shadow-md">
                                ${track.title}
                            </div>
                        </div>
                        <div class="flex justify-end gap-3 mt-1 items-baseline w-full">
                            <span class="text-xs font-mono text-cyan-400 font-bold tracking-wider truncate max-w-[15vw]">${track.artist}</span>
                            <span class="text-[10px] font-mono text-gray-300 bg-black/50 px-1 rounded flex-shrink-0">${track.duration}</span>
                        </div>
                    </div>
                `;
                div.onclick = () => {
                    if (selectedTrackIndex !== idx) {
                        selectedTrackIndex = idx;
                        if(track.id !== 'custom') {
                            document.getElementById('musicUpload').value = '';
                            document.getElementById('customFileName').innerText = "No file selected";
                        }
                        renderTrackList();
                        playPreview(idx);
                    }
                };
                list.appendChild(div);
            });
            
            // Check for overflow and apply marquee
            setTimeout(() => {
                tracks.forEach((track, idx) => {
                    const container = document.getElementById(`track-title-${idx}`);
                    if(container) {
                        const content = container.querySelector('.marquee-content');
                        if(content.scrollWidth > container.clientWidth) {
                            const dist = container.clientWidth - content.scrollWidth;
                            // Set custom property for animation
                            content.style.setProperty('--scroll-dist', (dist - 10) + 'px'); // extra padding
                            content.classList.add('animate-marquee');
                        }
                    }
                });
            }, 0);
        }
        
        // Auto-play listener unlocker
        const unlockAudio = () => {
            if (audio.ctx && audio.ctx.state === 'suspended') {
                audio.ctx.resume();
            }
            // Try playing if paused and selected
            if (audio.element.paused && audio.element.src) {
                 audio.element.play().catch(e => {});
            }
            // Remove listeners after interaction
            if (audio.ctx && audio.ctx.state === 'running') {
                document.removeEventListener('click', unlockAudio);
                document.removeEventListener('keydown', unlockAudio);
            }
        };
        
        document.addEventListener('click', unlockAudio);
        document.addEventListener('keydown', unlockAudio);

        // Init Track List and Attempt Autoplay
        renderTrackList();
        
        // Try initial autoplay of first track
        setTimeout(() => {
             playPreview(0);
        }, 500);

        document.getElementById('musicUpload').onchange = (e) => {
            const f = e.target.files[0];
            if(f) {
                const url = URL.createObjectURL(f);
                const customIdx = tracks.findIndex(t => t.id === 'custom');
                const newTrack = { 
                    id: 'custom',
                    title: f.name.replace(/\.[^/.]+$/, ""), // Remove extension
                    artist: "Custom Upload", 
                    src: url, 
                    cover: "https://images.unsplash.com/photo-1618005182384-a83a8bd57fbe?q=80&w=400&auto=format&fit=crop", 
                    duration: "Custom" 
                };
                
                if(customIdx !== -1) tracks[customIdx] = newTrack;
                else tracks.push(newTrack);
                
                selectedTrackIndex = tracks.findIndex(t => t.id === 'custom');
                document.getElementById('customFileName').innerText = f.name;
                renderTrackList();
                playPreview(selectedTrackIndex);
            }
        };

        function playPreview(index) {
            const track = tracks[index];
            if(!track || !track.src) return;

            // Init Audio Context logic
            if(!audio.ctx) {
                audio.ctx = new (window.AudioContext || window.webkitAudioContext)();
                audio.analyser = audio.ctx.createAnalyser();
                audio.analyser.fftSize = 2048;
                audio.dataArray = new Uint8Array(audio.analyser.frequencyBinCount);
            }

            if(!audio.setup) {
                const src = audio.ctx.createMediaElementSource(audio.element);
                src.connect(audio.analyser);
                audio.analyser.connect(audio.ctx.destination);
                audio.setup = true;
            }

            if(audio.ctx.state === 'suspended') audio.ctx.resume();

            if (audio.element.src !== track.src) {
                 audio.element.src = track.src;
            }
            
            audio.element.currentTime = 0;
            audio.element.volume = 0.5; // Menu volume
            audio.element.loop = true;  // Menu loop
            
            var playPromise = audio.element.play();
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    console.log("Auto-play was prevented by browser policy. Waiting for user interaction.");
                });
            }
        }

        // --- CLASSES ---

        class Player {
            constructor() {
                this.core = new PIXI.Graphics();
                this.core.lineStyle(2, 0xFFFFFF);
                this.core.beginFill(0x000000);
                this.drawShape(this.core);
                this.core.endFill();
                
                this.glow = new PIXI.Graphics();
                this.glow.lineStyle(6, 0xFFFFFF); 
                this.drawShape(this.glow);

                this.flame = new PIXI.Graphics();
                this.core.addChild(this.flame);

                this.x = 0; 
                this.y = 0;
                this.vx = 0;
                this.vy = 0;
                this.angle = 0;
                this.radius = 12;
                
                this.stats = {
                    speed: 6 + (saveData.upgrades.speed * 0.5),
                    maxHp: 100,
                    hp: 100,
                    cooldown: 0,
                    maxCooldown: Math.max(5, 20 - (saveData.upgrades.fireRate * 2))
                };
                
                this.shooting = false;
                
                coreContainer.addChild(this.core);
                glowContainer.addChild(this.glow);
            }

            drawShape(g) {
                g.moveTo(20, 0);
                g.lineTo(-12, 12);
                g.lineTo(-6, 0);
                g.lineTo(-12, -12);
                g.closePath();
            }

            update(dt) {
                if (gameState.isDying) return;

                let dx = 0, dy = 0;
                if (keys['w'] || keys['ArrowUp']) dy = -1;
                if (keys['s'] || keys['ArrowDown']) dy = 1;
                if (keys['a'] || keys['ArrowLeft']) dx = -1;
                if (keys['d'] || keys['ArrowRight']) dx = 1;

                if (dx !== 0 || dy !== 0) {
                    const len = Math.hypot(dx, dy);
                    dx /= len; dy /= len;
                }

                const acc = this.stats.speed * 0.1;
                const fric = 0.96;

                this.vx += dx * acc * dt;
                this.vy += dy * acc * dt;
                this.vx *= fric;
                this.vy *= fric;

                this.x += this.vx * dt;
                this.y += this.vy * dt;

                const limit = arenaApothem - this.radius;
                for(let i=0; i<8; i++) {
                    const theta = (i * Math.PI / 4) + (Math.PI / 8); 
                    const nx = Math.cos(theta);
                    const ny = Math.sin(theta);
                    const dist = this.x * nx + this.y * ny;
                    
                    if (dist > limit) {
                        const overlap = dist - limit;
                        this.x -= nx * overlap;
                        this.y -= ny * overlap;
                        const dot = this.vx * nx + this.vy * ny;
                        this.vx -= 1.5 * dot * nx;
                        this.vy -= 1.5 * dot * ny;
                        spawnParticles(this.x + nx*10, this.y + ny*10, 0xE879F9, 3);
                    }
                }

                this.core.x = this.glow.x = this.x;
                this.core.y = this.glow.y = this.y;
                
                const globalMouse = app.renderer.events.pointer.global;
                const localMouse = gameContainer.toLocal(globalMouse);
                this.angle = Math.atan2(localMouse.y - this.y, localMouse.x - this.x);
                this.core.rotation = this.glow.rotation = this.angle;

                if (this.stats.cooldown > 0) this.stats.cooldown -= dt;
                if (this.shooting && this.stats.cooldown <= 0) {
                    const dmg = 10 + (saveData.upgrades.damage * 5);
                    entities.bullets.push(new Bullet(this.x, this.y, this.angle, dmg));
                    this.stats.cooldown = this.stats.maxCooldown;
                    this.vx -= Math.cos(this.angle) * 0.2;
                    this.vy -= Math.sin(this.angle) * 0.2;
                    gameState.screenShake += 2;
                }

                this.flame.clear();
                if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
                    this.flame.beginFill(0x00FFFF);
                    this.flame.moveTo(-14, 0);
                    this.flame.lineTo(-24 - Math.random()*10, 0);
                    this.flame.lineTo(-14, 6);
                    this.flame.endFill();
                }
            }

            takeDamage(amt) {
                if (gameState.isDying) return;
                this.stats.hp -= amt;
                document.getElementById('healthFill').style.width = Math.max(0, (this.stats.hp / this.stats.maxHp * 100)) + '%';
                spawnParticles(this.x, this.y, 0x00FFFF, 8);
                gameState.screenShake = 15; // Hit shake
                if (this.stats.hp <= 0) startDeathSequence();
            }

            destroy() {
                coreContainer.removeChild(this.core);
                glowContainer.removeChild(this.glow);
                this.core.destroy();
                this.glow.destroy();
            }
        }

        class Bullet {
            constructor(x, y, angle, dmg) {
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * 12;
                this.vy = Math.sin(angle) * 12;
                this.life = 60;
                this.damage = dmg;
                this.radius = 4; 

                this.core = new PIXI.Graphics();
                this.core.beginFill(0x00FFFF);
                this.core.drawCircle(0,0,3);
                this.core.endFill();
                
                this.glow = new PIXI.Graphics();
                this.glow.beginFill(0x00FFFF, 0.8);
                this.glow.drawCircle(0,0,8); 
                this.glow.endFill();

                this.core.x = this.glow.x = x; 
                this.core.y = this.glow.y = y;
                
                coreContainer.addChild(this.core);
                glowContainer.addChild(this.glow);
            }
            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.life -= dt;
                this.core.x = this.glow.x = this.x;
                this.core.y = this.glow.y = this.y;
                return this.life <= 0;
            }
            destroy() {
                coreContainer.removeChild(this.core);
                glowContainer.removeChild(this.glow);
                this.core.destroy();
                this.glow.destroy();
            }
        }

        class Enemy {
            constructor() {
                const angle = Math.random() * Math.PI * 2;
                const r = arenaApothem + 50;
                this.x = Math.cos(angle) * r;
                this.y = Math.sin(angle) * r;
                
                const roll = Math.random();
                if (roll < 0.6) this.type = 0; 
                else if (roll < 0.85) this.type = 1; 
                else this.type = 2; 

                this.core = new PIXI.Graphics();
                this.glow = new PIXI.Graphics();
                this.vx = 0; this.vy = 0;

                if (this.type === 0) {
                    this.speed = 2 + Math.random();
                    this.hp = 20 + (gameState.score / 50);
                    this.color = 0xF43F5E;
                    this.radius = 12;
                    this.value = 1;
                } else if (this.type === 1) {
                    this.speed = 1;
                    this.hp = 60 + (gameState.score / 20);
                    this.color = 0xA855F7;
                    this.radius = 20;
                    this.value = 5;
                } else {
                    this.speed = 0;
                    this.hp = 30;
                    this.color = 0x22C55E;
                    this.radius = 15;
                    this.value = 3;
                    this.vx = -Math.cos(angle) * 3;
                    this.vy = -Math.sin(angle) * 3;
                    this.time = 0;
                }

                this.draw(this.core, 2, 1.0, false);
                this.draw(this.glow, 6, 0.8, true); 

                this.core.x = this.glow.x = this.x;
                this.core.y = this.glow.y = this.y;
                
                coreContainer.addChild(this.core);
                glowContainer.addChild(this.glow);
            }

            draw(g, thickness, alpha, isGlow) {
                g.lineStyle(thickness, this.color, alpha);
                if (this.type === 0) g.drawRect(-12,-12,24,24);
                else if (this.type === 1) g.drawCircle(0,0,20);
                else if (this.type === 2) {
                    if(!isGlow) g.beginFill(this.color);
                    g.drawRect(-10,-10,20,20);
                    if(!isGlow) g.endFill();
                }
            }

            update(dt) {
                if (this.type === 2) {
                    this.x += this.vx * dt;
                    this.y += this.vy * dt;
                    this.time += 0.05 * dt;
                    this.x += Math.sin(this.time);
                    this.y += Math.cos(this.time);
                    const rot = 0.05 * dt;
                    this.core.rotation += rot;
                    this.glow.rotation += rot;
                    
                    if (Math.hypot(this.x, this.y) > arenaApothem + 200) return true; 
                } else {
                    if (entities.player) {
                        const angle = Math.atan2(entities.player.y - this.y, entities.player.x - this.x);
                        this.x += Math.cos(angle) * this.speed * dt;
                        this.y += Math.sin(angle) * this.speed * dt;
                        const rot = 0.05 * dt;
                        this.core.rotation += rot;
                        this.glow.rotation += rot;
                    }
                }

                this.core.x = this.glow.x = this.x;
                this.core.y = this.glow.y = this.y;

                if (!gameState.isDying && entities.player) {
                    const dist = Math.hypot(this.x - entities.player.x, this.y - entities.player.y);
                    if (dist < this.radius + entities.player.radius) {
                        entities.player.takeDamage(10);
                        
                        if (!entities.player) return false;

                        if (this.type !== 1) {
                            this.hp = 0;
                            spawnParticles(this.x, this.y, this.color, 10);
                            spawnShockwave(this.x, this.y, this.color);
                        } else {
                            this.hp -= 20;
                            entities.player.vx += Math.cos(Math.atan2(entities.player.y - this.y, entities.player.x - this.x)) * 10;
                            entities.player.vy += Math.sin(Math.atan2(entities.player.y - this.y, entities.player.x - this.x)) * 10;
                        }
                    }
                }

                return this.hp <= 0;
            }

            destroy() {
                coreContainer.removeChild(this.core);
                glowContainer.removeChild(this.glow);
                this.core.destroy();
                this.glow.destroy();
            }
        }

        class Loot {
            constructor(x, y, val) {
                this.x = x; this.y = y; this.val = val;
                this.vx = (Math.random()-0.5)*2;
                this.vy = (Math.random()-0.5)*2;
                
                this.core = new PIXI.Graphics();
                this.glow = new PIXI.Graphics();
                
                const drawLoot = (g, fill) => {
                    g.beginFill(0xFBBF24, fill ? 1.0 : 0.8); 
                    g.drawRect(-3,-3,6,6);
                    g.endFill();
                };
                
                drawLoot(this.core, true);
                drawLoot(this.glow, false);
                this.glow.scale.set(1.8); 

                this.core.x = this.glow.x = x; 
                this.core.y = this.glow.y = y;
                
                coreContainer.addChild(this.core);
                glowContainer.addChild(this.glow);
            }
            update(dt) {
                if (!entities.player) return false;
                
                const d = Math.hypot(this.x - entities.player.x, this.y - entities.player.y);
                const range = 100 + (saveData.upgrades.magnet * 30);

                if (d < range && !gameState.isDying) {
                    const ang = Math.atan2(entities.player.y - this.y, entities.player.x - this.x);
                    const spd = 8 + (500/d);
                    this.x += Math.cos(ang) * spd * dt;
                    this.y += Math.sin(ang) * spd * dt;
                } else {
                    this.x += this.vx * dt;
                    this.y += this.vy * dt;
                    this.vx *= 0.98; this.vy *= 0.98;
                }

                const rot = 0.1 * dt;
                this.core.rotation += rot;
                this.glow.rotation += rot;
                this.core.x = this.glow.x = this.x;
                this.core.y = this.glow.y = this.y;

                if (d < 15 && !gameState.isDying) {
                    gameState.runCurrency += this.val;
                    gameState.score += 10;
                    updateHUD();
                    return true;
                }
                return false;
            }
            destroy() {
                coreContainer.removeChild(this.core);
                glowContainer.removeChild(this.glow);
                this.core.destroy();
                this.glow.destroy();
            }
        }

        class Particle {
            constructor(x, y, color, speed) {
                this.core = new PIXI.Graphics();
                this.glow = new PIXI.Graphics();
                
                this.core.beginFill(color); this.core.drawCircle(0,0,2); this.core.endFill();
                this.glow.beginFill(color); this.glow.drawCircle(0,0,5); this.glow.endFill();

                this.x = x; this.y = y;
                this.core.x = this.glow.x = x; 
                this.core.y = this.glow.y = y;
                
                const a = Math.random() * Math.PI * 2;
                const s = Math.random() * speed;
                this.vx = Math.cos(a) * s;
                this.vy = Math.sin(a) * s;
                this.life = 1.0;
                
                coreContainer.addChild(this.core);
                glowContainer.addChild(this.glow);
            }
            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.life -= 0.03 * dt;
                this.vx *= 0.95; 
                this.vy *= 0.95;
                
                this.core.x = this.glow.x = this.x;
                this.core.y = this.glow.y = this.y;
                this.core.alpha = this.glow.alpha = this.life;
                
                return this.life <= 0;
            }
            destroy() {
                coreContainer.removeChild(this.core);
                glowContainer.removeChild(this.glow);
                this.core.destroy();
                this.glow.destroy();
            }
        }

        class Shockwave {
            constructor(x, y, color) {
                this.g = new PIXI.Graphics();
                this.x = x; this.y = y; this.color = color;
                this.radius = 1;
                this.life = 1.0;
                this.g.x = x; this.g.y = y;
                glowContainer.addChild(this.g); 
            }
            update(dt) {
                this.radius += 8 * dt; 
                this.life -= 0.05 * dt;
                
                this.g.clear();
                this.g.lineStyle(4 * this.life, this.color, this.life);
                this.g.drawCircle(0,0, this.radius);
                
                return this.life <= 0;
            }
            destroy() {
                glowContainer.removeChild(this.g);
                this.g.destroy();
            }
        }

        function spawnParticles(x, y, color, count) {
            for(let i=0; i<count; i++) {
                entities.particles.push(new Particle(x, y, color, 8)); 
            }
        }

        function spawnShockwave(x, y, color) {
            entities.shockwaves.push(new Shockwave(x, y, color));
        }

        function drawBorder() {
            entities.borderCore.clear();
            entities.borderGlow.clear();
            
            const drawPoly = (g) => {
                const R = arenaApothem / Math.cos(Math.PI/8);
                for(let i=0; i<=8; i++) {
                    const theta = i * Math.PI / 4; // FIXED ANGLE
                    const vx = Math.cos(theta) * R;
                    const vy = Math.sin(theta) * R;
                    if(i===0) g.moveTo(vx, vy);
                    else g.lineTo(vx, vy);
                }
            };

            entities.borderGlow.lineStyle(15 + (audio.beatValue * 25), 0xD946EF, 0.6); 
            drawPoly(entities.borderGlow);
            entities.borderCore.lineStyle(4, 0xD946EF, 1.0);
            drawPoly(entities.borderCore);
        }

        function updateHUD() {
            document.getElementById('scoreVal').innerText = gameState.score;
            document.getElementById('currencyVal').innerText = (saveData.currency + gameState.runCurrency);
        }

        function startAudio() {
            if(!audio.ctx) {
                audio.ctx = new (window.AudioContext || window.webkitAudioContext)();
                audio.analyser = audio.ctx.createAnalyser();
                audio.analyser.fftSize = 2048; // Higher resolution for bass
                audio.dataArray = new Uint8Array(audio.analyser.frequencyBinCount);
            }
            
            const currentTrack = tracks[selectedTrackIndex];
            if(currentTrack && currentTrack.src) {
                audio.element.src = currentTrack.src;
                
                if(!audio.setup) {
                    const src = audio.ctx.createMediaElementSource(audio.element);
                    src.connect(audio.analyser); 
                    audio.analyser.connect(audio.ctx.destination);
                    audio.setup = true;
                }
                
                if(audio.ctx.state === 'suspended') audio.ctx.resume();
                audio.element.currentTime = 0;
                audio.element.playbackRate = 1;
                audio.element.volume = 1;
                audio.element.play();
                audio.element.loop = false; // Reset to no-loop for game mode
                document.getElementById('songProgressContainer').classList.remove('opacity-0');
            } else {
                document.getElementById('songProgressContainer').classList.add('opacity-0');
            }
        }

        function stopAudio() {
            if (audio.element) {
                audio.element.pause();
                audio.element.currentTime = 0;
            }
        }

        function analyzeAudio() {
            // Check for end of track FIRST
            if(audio.element.duration) {
                const p = (audio.element.currentTime / audio.element.duration) * 100;
                document.getElementById('songProgressFill').style.width = p + '%';
                
                if((audio.element.ended || audio.element.currentTime >= audio.element.duration) && gameState.running) {
                     winGame();
                     return;
                }
            }

            if(!audio.ctx || audio.element.paused) {
                audio.beatValue *= 0.5; // Fast decay on silence
                return;
            }
            audio.analyser.getByteFrequencyData(audio.dataArray);
            
            // Focus strictly on Kick/Sub-Bass (approx 40Hz - 100Hz)
            // 44100 / 2048 = ~21.5Hz per bin
            // Bin 2 = ~43Hz
            // Bin 5 = ~107Hz
            let sum = 0;
            const startBin = 2;
            const endBin = 6;
            for(let i=startBin; i<endBin; i++) sum += audio.dataArray[i];
            
            const rawAvg = sum / (endBin - startBin);
            
            // Normalize (0-255 -> 0.0-1.0)
            let input = rawAvg / 255;
            
            // Steep curve to isolate only the kick hits (transients)
            // This prevents "steady glowing" on sustained bass notes
            const norm = Math.pow(input, 12); 
            
            if(norm > audio.beatValue) {
                audio.beatValue = norm; // Instant Attack
            } else {
                audio.beatValue *= 0.4; // Very Fast Decay (Strobe feel)
            }

            document.getElementById('scoreContainer').style.transform = `scale(${1 + audio.beatValue * 0.2})`;
        }

        let lastTime = 0;
        app.ticker.add((delta) => {
            // Audio Analysis & Background Visuals (Always Run)
            analyzeAudio();

            // DYNAMIC BACKGROUND FLASH
            bgGraphics.clear();
            bgGraphics.beginFill(0x220033, audio.beatValue * 0.3); // Purple flash
            bgGraphics.drawRect(-width, -height, width*2, height*2);
            bgGraphics.endFill();

            // DYNAMIC GRID
            gridGraphics.clear();
            gridGraphics.lineStyle(1 + (audio.beatValue * 2), 0x333333, 0.5 + audio.beatValue);
            const gridSize = 50;
            for(let x = -width; x <= width; x += gridSize) {
                gridGraphics.moveTo(x, -height); gridGraphics.lineTo(x, height);
            }
            for(let y = -height; y <= height; y += gridSize) {
                gridGraphics.moveTo(-width, y); gridGraphics.lineTo(width, y);
            }

            // STRONGER NEON
            neonFilter.blur = 10 + (audio.beatValue * 15);
            glowContainer.alpha = 0.6 + (audio.beatValue * 0.4);

            // Border (Always visible)
            drawBorder();

            // Menu Mode (No Game Logic)
            if (!gameState.running) {
                // Menu Pulse Zoom
                const targetZoom = 1.0 + (audio.beatValue * 0.02);
                const current = gameContainer.scale.x;
                gameContainer.scale.set(current + (targetZoom - current) * 0.1);
                
                // Reset camera position
                gameContainer.x = width/2;
                gameContainer.y = height/2;
                return;
            }

            // --- GAME LOGIC START ---
            const dt = delta * gameState.timeScale;

            if (gameState.isDying) {
                gameState.timeScale = Math.max(0, gameState.timeScale - 0.005 * delta); 
                gameState.deathTimer -= delta;
                
                if(audio.element.playbackRate > 0.1) audio.element.playbackRate *= 0.99;
                if(audio.element.volume > 0.05) audio.element.volume *= 0.98;
                else audio.element.pause(); 

                const currentScale = gameContainer.scale.x;
                gameContainer.scale.set(currentScale + (0.001 * delta));

                if (gameState.deathTimer <= 0) endGame();
            } else {
                gameState.timeScale = 1.0;
                const targetZoom = 1.0 + (audio.beatValue * 0.05); // Pump zoom
                gameContainer.scale.set(
                    gameContainer.scale.x + (targetZoom - gameContainer.scale.x) * 0.1
                );
            }

            if(entities.player || gameState.isDying) { 
                let targetX = width/2;
                let targetY = height/2;

                if (entities.player) {
                    // MORE AGGRESSIVE SWAY (was -0.1)
                    targetX += entities.player.x * -0.35;
                    targetY += entities.player.y * -0.35;
                }

                const shakeX = (Math.random() - 0.5) * gameState.screenShake;
                const shakeY = (Math.random() - 0.5) * gameState.screenShake;

                gameContainer.x += (targetX - gameContainer.x) * 0.1; 
                gameContainer.y += (targetY - gameContainer.y) * 0.1;
                
                gameContainer.x += shakeX;
                gameContainer.y += shakeY;
            }
            
            if(gameState.screenShake > 0) gameState.screenShake *= 0.85;

            glitchGraphics.clear();
            if(gameState.isDying && Math.random() > 0.7) {
                const w = Math.random() * width;
                const h = Math.random() * 50;
                const x = Math.random() * width;
                const y = Math.random() * height;
                glitchGraphics.beginFill(Math.random() > 0.5 ? 0x00FFFF : 0xFF00FF, 0.3);
                glitchGraphics.drawRect(x, y, w, h);
                glitchGraphics.endFill();
            }

            if (!gameState.isDying) {
                gameState.spawnTimer += dt;
                const rate = Math.max(20, 120 - (gameState.score / 50));
                const cap = 5 + (gameState.score / 100);
                if (gameState.spawnTimer > rate && entities.enemies.length < cap) {
                    entities.enemies.push(new Enemy());
                    gameState.spawnTimer = 0;
                }
            }

            if (entities.player) {
                entities.player.update(dt);
            }

            for (let i = entities.bullets.length - 1; i >= 0; i--) {
                const b = entities.bullets[i];
                if (b.update(dt)) {
                    b.destroy();
                    entities.bullets.splice(i, 1);
                } else {
                    for (let j = entities.enemies.length - 1; j >= 0; j--) {
                        const e = entities.enemies[j];
                        const dist = Math.hypot(b.x - e.x, b.y - e.y);
                        if (dist < b.radius + e.radius) {
                            e.hp -= b.damage;
                            spawnParticles(e.x, e.y, 0x00FFFF, 3);
                            gameState.screenShake = 3; 
                            
                            b.destroy();
                            entities.bullets.splice(i, 1);
                            
                            if (e.hp <= 0) {
                                if(!gameState.isDying) {
                                    const count = Math.ceil(Math.random()*3);
                                    for(let k=0; k<count; k++) entities.loot.push(new Loot(e.x, e.y, e.value));
                                }
                                spawnParticles(e.x, e.y, e.color, 15);
                                spawnShockwave(e.x, e.y, e.color); 
                                gameState.screenShake = 15; 
                                e.destroy();
                                entities.enemies.splice(j, 1);
                            }
                            break; 
                        }
                    }
                }
            }

            for (let i = entities.enemies.length - 1; i >= 0; i--) {
                const e = entities.enemies[i];
                if (e.update(dt)) {
                    e.destroy();
                    entities.enemies.splice(i, 1);
                }
            }

            for (let i = entities.loot.length - 1; i >= 0; i--) {
                const l = entities.loot[i];
                if (l.update(dt)) {
                    l.destroy();
                    entities.loot.splice(i, 1);
                }
            }

            for (let i = entities.particles.length - 1; i >= 0; i--) {
                const p = entities.particles[i];
                if (p.update(dt)) {
                    p.destroy();
                    entities.particles.splice(i, 1);
                }
            }

            for (let i = entities.shockwaves.length - 1; i >= 0; i--) {
                const s = entities.shockwaves[i];
                if (s.update(dt)) {
                    s.destroy();
                    entities.shockwaves.splice(i, 1);
                }
            }
        });

        const keys = {};
        window.onkeydown = e => keys[e.key] = true;
        window.onkeyup = e => keys[e.key] = false;
        window.onmousedown = () => { if(entities.player) entities.player.shooting = true; };
        window.onmouseup = () => { if(entities.player) entities.player.shooting = false; };

        function startGame() {
            if(entities.player) entities.player.destroy();
            entities.bullets.forEach(e => e.destroy());
            entities.enemies.forEach(e => e.destroy());
            entities.loot.forEach(e => e.destroy());
            entities.particles.forEach(e => e.destroy());
            entities.shockwaves.forEach(e => e.destroy());
            
            entities.bullets = [];
            entities.enemies = [];
            entities.loot = [];
            entities.particles = [];
            entities.shockwaves = [];

            gameState.score = 0;
            gameState.runCurrency = 0;
            gameState.isDying = false;
            gameState.timeScale = 1.0;
            
            entities.player = new Player();
            drawBorder();
            updateHUD();
            startAudio();

            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('gameOver').classList.add('hidden');
            document.getElementById('gameSuccess').classList.add('hidden');
            document.getElementById('shopMenu').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            
            gameState.running = true;
        }

        function startDeathSequence() {
            gameState.isDying = true;
            gameState.deathTimer = 300; 
            gameState.screenShake = 30; 
            spawnParticles(entities.player.x, entities.player.y, 0x00FFFF, 30);
            spawnShockwave(entities.player.x, entities.player.y, 0x00FFFF);
            entities.player.destroy();
            entities.player = null;
        }

        function endGame() {
            gameState.running = false;
            saveData.currency += gameState.runCurrency;
            saveGame();
            document.getElementById('finalShards').innerText = gameState.runCurrency;
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('gameOver').classList.remove('hidden');
        }

        function winGame() {
            gameState.running = false;
            stopAudio(); // Stop audio immediately
            const bonus = 500;
            gameState.runCurrency += bonus;
            saveData.currency += gameState.runCurrency;
            saveGame();
            document.getElementById('successShards').innerText = gameState.runCurrency + " (+500 BONUS)";
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('gameSuccess').classList.remove('hidden');
        }

        const costs = { base: 100, scale: 1.5 };
        function getCost(lvl) { return Math.floor(costs.base * Math.pow(costs.scale, lvl - 1)); }
        
        function updateShop() {
            document.getElementById('shopCurrency').innerText = saveData.currency;
            document.getElementById('currencyVal').innerText = saveData.currency;
            
            ['damage', 'fireRate', 'speed', 'magnet'].forEach(type => {
                const lvl = saveData.upgrades[type];
                const cost = getCost(lvl);
                const map = {damage: 'Dmg', fireRate: 'Rate', speed: 'Spd', magnet: 'Mag'};
                const id = map[type];
                
                const btn = document.getElementById('buy'+id);
                document.getElementById(id.toLowerCase()+'Cost').innerText = cost;
                
                if(saveData.currency >= cost) {
                    btn.disabled = false;
                    btn.onclick = () => {
                        saveData.currency -= cost;
                        saveData.upgrades[type]++;
                        saveGame();
                    }
                } else {
                    btn.disabled = true;
                }
            });
        }

        document.getElementById('startBtn').onclick = startGame;
        document.getElementById('retryBtn').onclick = startGame;
        document.getElementById('successRetryBtn').onclick = startGame;
        document.getElementById('shopBtn').onclick = () => { 
            updateShop(); 
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('shopMenu').classList.remove('hidden');
        };
        document.getElementById('goShopBtn').onclick = () => {
            updateShop();
            document.getElementById('gameOver').classList.add('hidden');
            document.getElementById('shopMenu').classList.remove('hidden');
        };
        document.getElementById('successGoShopBtn').onclick = () => {
            updateShop();
            document.getElementById('gameSuccess').classList.add('hidden');
            document.getElementById('shopMenu').classList.remove('hidden');
        };
        document.getElementById('closeShop').onclick = () => {
            document.getElementById('shopMenu').classList.add('hidden');
            document.getElementById('mainMenu').classList.remove('hidden');
        };

        drawBorder();
    </script>
</body>

</html>
